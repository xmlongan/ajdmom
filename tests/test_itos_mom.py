from fractions import Fraction as Frac
import pytest

from ajdmom.poly import Poly
from ajdmom.itos_mom import c
from ajdmom.itos_mom import int_et
from ajdmom.itos_mom import moment_IEI_IEII


@pytest.mark.parametrize(
    "n1n2mi, constant",
    [
        ((1, 1, 1, 0), ((1, 1, 1), 1)),
        ((1, 1, 1, 1), ((1, 1, 2), -1)),
        #
        ((2, 1, 1, 0), ((2, 1, 1), 1)),
        ((2, 1, 1, 1), ((2, 1, 2), -1)),
        #
        ((1, 2, 1, 0), ((1, 2, 1), 1)),
        ((1, 2, 1, 1), ((1, 2, 2), -1))
    ]
)
def test_c(n1n2mi, constant):
    """Test constant :math:`c_{n_1n_2mi}` in :eq:`c-n_1n_2mi`"""
    n1, n2, m, i = n1n2mi
    assert c(n1, n2, m, i) == constant


@pytest.mark.parametrize(
    "n1n2m, poly",
    [
        # n1 = 0, n2 = 0, m = 0
        ((0, 0, 0), {((0, 0, 0), (0, 0), 1): 1}),
        # n1 = 0, n2 = 0, m != 0
        ((0, 0, 1), {((0, 0, 0), (0, 0), 2): Frac(1, 2)}),
        ((0, 0, 2), {((0, 0, 0), (0, 0), 3): Frac(1, 3)}),
        ((0, 0, 3), {((0, 0, 0), (0, 0), 4): Frac(1, 4)}),
        # n1 != 0 or n2 != 0, m = 0
        ((1, 0, 0), {((1, 0, 1), (1, 0), 0): 1, ((1, 0, 1), (0, 0), 0): -1}),
        ((0, 1, 0), {((0, 1, 1), (0, 1), 0): 1, ((0, 1, 1), (0, 0), 0): -1}),
        ((1, 1, 0), {((1, 1, 1), (1, 1), 0): 1, ((1, 1, 1), (0, 0), 0): -1}),
        ((2, 3, 0), {((2, 3, 1), (2, 3), 0): 1, ((2, 3, 1), (0, 0), 0): -1}),
        # n1 != 0 or n2 != 0, m != 0
        ((1, 0, 1), {((1, 0, 1), (1, 0), 1): 1,
                     ((1, 0, 2), (0, 0), 0): 1,
                     ((1, 0, 2), (1, 0), 0): -1}),
        ((0, 1, 1), {((0, 1, 1), (0, 1), 1): 1,
                     ((0, 1, 2), (0, 0), 0): 1,
                     ((0, 1, 2), (0, 1), 0): -1}),
        ((2, 3, 4), {((2, 3, 1), (2, 3), 4): 1,
                     ((2, 3, 2), (2, 3), 3): -4,
                     ((2, 3, 3), (2, 3), 2): 12,
                     ((2, 3, 4), (2, 3), 1): -24,
                     ((2, 3, 5), (0, 0), 0): -24,
                     ((2, 3, 5), (2, 3), 0): 24})
    ]
)
def test_int_et(n1n2m, poly):
    kf = ['(n1*k1+n2*k2)^{-}', 'e^{(n1*k1+n2*k2)[t-(n-1)h]}', '[t-(n-1)h]']
    expected = Poly(poly)
    expected.set_keyfor(kf)
    #
    n1, n2, m = n1n2m
    assert int_et(n1, n2, m) == expected


@pytest.mark.parametrize(
    "n4n5n6n7n8, poly",
    [
        # n4+...+n8 = 0
        ((0, 0, 0, 0, 0), {(((0, 0, 0),), (0, 0), (0, 0), 0, 0, 0, 0, 0, 0, 0): 1}),
        # n4+...+n8 = 1
        ((1, 0, 0, 0, 0), {}),
        ((0, 1, 0, 0, 0), {}),
        ((0, 0, 1, 0, 0), {}),
        ((0, 0, 0, 1, 0), {}),
        ((0, 0, 0, 0, 1), {}),
        # n4+...+n8 = 2
        ((2, 0, 0, 0, 0), {(((1, 0, 1),), (2, 0), (0, 0), 0, 1, 0, 0, 0, 0, 0): -1,
                           (((1, 0, 1),), (2, 0), (1, 0), 0, 0, 1, 0, 0, 0, 0): -1,
                           (((1, 0, 1),), (2, 0), (1, 0), 0, 1, 0, 0, 0, 0, 0): 1,
                           (((2, 0, 1),), (2, 0), (0, 0), 0, 0, 1, 0, 0, 0, 0): 1,
                           (((2, 0, 1),), (2, 0), (2, 0), 0, 0, 1, 0, 0, 0, 0): 1}),
        ((1, 1, 0, 0, 0), {(((0, 0, 0),), (1, 0), (0, 0), 1, 0, 1, 0, 0, 0, 0): -1,
                           (((0, 0, 0),), (1, 0), (0, 0), 1, 1, 0, 0, 0, 0, 0): 1,
                           (((1, 0, 1),), (1, 0), (0, 0), 0, 0, 1, 0, 0, 0, 0): -1,
                           (((1, 0, 1),), (1, 0), (1, 0), 0, 0, 1, 0, 0, 0, 0): 1}),
        ((0, 2, 0, 0, 0), {(((0, 0, 0),), (0, 0), (0, 0), 1, 0, 1, 0, 0, 0, 0): 1,
                           (((1, 0, 1),), (0, 0), (-1, 0), 0, 0, 1, 0, 0, 0, 0): 1,
                           (((1, 0, 1),), (0, 0), (-1, 0), 0, 1, 0, 0, 0, 0, 0): -1,
                           (((1, 0, 1),), (0, 0), (0, 0), 0, 0, 1, 0, 0, 0, 0): -1,
                           (((1, 0, 1),), (0, 0), (0, 0), 0, 1, 0, 0, 0, 0, 0): 1}),
        # n4+...+n8 >= 3
        ((3, 0, 0, 0, 0),
         {(((1, 0, 1), (2, 0, 1)), (3, 0), (0, 0), 0, 0, 1, 1, 0, 0, 0): Frac(-3, 1),
          (((1, 0, 1), (2, 0, 1)), (3, 0), (1, 0), 0, 0, 1, 1, 0, 0, 0): Frac(3, 1),
          (((1, 0, 2),), (3, 0), (0, 0), 0, 1, 0, 1, 0, 0, 0): Frac(3, 1),
          (((1, 0, 2),), (3, 0), (1, 0), 0, 1, 0, 1, 0, 0, 0): Frac(-3, 1),
          (((2, 0, 1), (1, 0, 1)), (3, 0), (0, 0), 0, 0, 1, 1, 0, 0, 0): Frac(3, 1),
          (((2, 0, 1), (1, 0, 1)), (3, 0), (0, 0), 0, 1, 0, 1, 0, 0, 0): Frac(-3, 1),
          (((2, 0, 1), (1, 0, 1)), (3, 0), (2, 0), 0, 0, 1, 1, 0, 0, 0): Frac(-3, 1),
          (((2, 0, 1), (1, 0, 1)), (3, 0), (2, 0), 0, 1, 0, 1, 0, 0, 0): Frac(3, 1),
          (((3, 0, 1), (2, 0, 1)), (3, 0), (0, 0), 0, 0, 1, 1, 0, 0, 0): Frac(-3, 1),
          (((3, 0, 1), (2, 0, 1)), (3, 0), (3, 0), 0, 0, 1, 1, 0, 0, 0): Frac(3, 1)})
    ]
)
def test_moment_IEI_IEII(n4n5n6n7n8, poly):
    kf = ('(n_1m*k1+n_2m*k2)^{-i_m},...,(n_11*k1+n_21*k2)^{-i_1}',
          'e^{(m_4*k1+m_6*k2)(n-1)h}', 'e^{(j_1*k1+j_2*k2)[t-(n-1)h]}', '[t-(n-1)h]',
          'v_{1,n-1}', 'theta1', 'sigma_v1', 'v_{2,n-1}', 'theta2', 'sigma_v2')
    expected = Poly(poly)
    expected.set_keyfor(kf)
    #
    n4, n5, n6, n7, n8 = n4n5n6n7n8
    #
    assert moment_IEI_IEII(n4, n5, n6, n7, n8) == expected
